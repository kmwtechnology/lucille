# This is a configuration file for indexing project files into OpenSearch with vector capabilities
# It is in HOCON format, a superset of JSON

connectors: [
  {
    name: "fileConnector",
    class: "com.kmwllc.lucille.connector.FileConnector",
    pipeline: "pipeline1",
    # Path to the Lucille project directory (will be set as environment variable)
    pathToStorage: ${PROJECT_PATH}
    # Include various file types we want to process
    includeSuffixes: [".md", ".html", ".java", ".properties", ".xml", ".conf", ".csv"]
    # Exclude directories we don't want to process
    excludePatterns: [
      "**/target/**",
      "**/.idea/**",
      "**/.vscode/**",
      "**/.github/**",
      "**/.svn/**",
      "**/.hg/**",
      "**/.tox/**",
      "**/.pytest_cache/**",
      "**/.DS_Store/**",
      "node_modules/",
      "dist/",
      "*.py[cod]",
      "*.iml",
      "*.project",
      ".settings",
      ".classpath",
      "TEST*.xml",
      "Thumbs.db",
      "*.mp4",
      "*.tiff",
      "*.avi",
      "*.flv",
      "*.mov",
      "*.wmv",
      "**/*.class",
      "**/*.jar",
      "**/pom.xml",
      "**/*.log",
      "**/test/**/*"
    ]
    # Limit the number of files to process (increase for production use)
    maxDocs: 100
    # Simple text extraction should be false since we're using Tika for extraction
    extractText: false
    # Add throttling to control processing rate and respect API limits
    throttleDelayMs: 100
    batchSize: 5
  }
]

pipelines: [
  {
    name: "pipeline1",
    stages: [
      # Extract Text with Tika - using correct file_path field from FileConnector
      {
        name: "extractContent"
        class: "com.kmwllc.lucille.tika.stage.TextExtractor"
        file_path_field: "file_path"
        text_field: "text"
        metadata_prefix: "tika"
      },
      # Rename extracted fields
      {
        name: "renameFields",
        class: "com.kmwllc.lucille.stage.RenameFields"
        fieldMapping: {
          "text": "content",
          "path": "full_path",
          "name": "filename"
        }
        update_mode: "overwrite"
      },
      # Add default content type if none exists
      {
        name: "addDefaultContentType",
        class: "com.kmwllc.lucille.stage.SetStaticValues"
        static_values: {
          "content_type": "application/octet-stream"
        }
        update_mode: "skip"
      },
      # Copy Tika content type field
      {
        name: "copyContentType",
        class: "com.kmwllc.lucille.stage.CopyFields"
        source: ["tika_content_type"]
        dest: ["content_type"]
        update_mode: "overwrite"  # Changed from "skip" to "overwrite" to ensure Tika values take precedence
      },
      # Copy the content to chunk_text field for embedding
      {
        name: "copyToChunk",
        class: "com.kmwllc.lucille.stage.CopyFields"
        source: ["content"]
        dest: ["chunk_text"]
      },
      # Add text chunking stage to break content into smaller chunks
      {
        name: "textChunker",
        class: "com.kmwllc.lucille.stage.ChunkText"
        source: "chunk_text"
        dest: "chunk_text"
        chunking_method: "fixed"
        length_to_split: 2000
        clean_chunks: true
        chunks_to_merge: 1
        overlap_percentage: 10
      },
      # Emit chunk children as separate documents
      {
        name: "emitChunks",
        class: "com.kmwllc.lucille.stage.EmitNestedChildren"
        drop_parent: true
        fields_to_copy: {
          "path": "path"
          "file_path": "file_path"
          "full_path": "full_path"
          "filename": "filename"
          "content_type": "content_type"
          "file_size_bytes": "file_size_bytes"
          "file_modification_date": "file_modification_date"
          "file_creation_date": "file_creation_date"
        }
      },
      # Generate embeddings using Google Gemini API
      {
        name: "geminiEmbed",
        class: "com.kmwllc.lucille.example.GeminiEmbed"
        source: "chunk_text"
        dest: "chunk_vector"
        embed_document: true
        embed_children: false
        api_key: ${?GEMINI_API_KEY}
        model_name: "text-embedding-004"
        dimensions: 768
        request_timeout_millis: 30000
      }
    ],
    "destination": {
      "type": "opensearch",
      "url": ${?OPENSEARCH_URL},
      "index": ${?OPENSEARCH_INDEX}
    }
  }
]

indexer {
  type: "OpenSearch"
  batchTimeout: 2000
  batchSize: 100
  sendEnabled: true
}

opensearch {
  # OpenSearch URL will be set as environment variable
  url: ${OPENSEARCH_URL}
  # Index name will be set as environment variable
  index: ${OPENSEARCH_INDEX}
  acceptInvalidCert: true
}

worker {
  pipeline: "pipeline1"
  # Reduced to 2 threads to respect Gemini API rate limits
  threads: 2
  # Add sleep between documents to control rate
  sleepBetweenDocs: 40
  # Add delay on processor errors (but do not use maxRetries to avoid ZooKeeper dependency)
  sleepOnProcessorError: 500
}

publisher {
  queueCapacity: 100
  # Add batch size configuration for the publisher
  batchSize: 10
  # Add timeout configuration for the publisher
  batchTimeout: 10000
}

log {
  seconds: 30
}

// Pipeline for processing files with vector embeddings
pipeline {
  name: "pipeline1"
  source {
    type: "file"
    name: "fileConnector"
    path: ".."
    includes: [
      "**/*.java",
      "**/*.md",
      "**/*.yaml",
      "**/*.yml",
      "**/*.json",
      "**/*.conf",
      "**/*.properties"
    ]
    excludes: [
      "**/target/**",
      "**/test/**",
      "**/.git/**",
      "**/node_modules/**",
      "**/.idea/**",
      "**/.vscode/**",
      "**/.github/**",
      "**/.svn/**",
      "**/.hg/**",
      "**/.tox/**",
      "**/.pytest_cache/**",
      "**/.DS_Store/**",
      "dist/",
      "*.py[cod]",
      "*.iml",
      "*.project",
      ".settings",
      ".classpath",
      "TEST*.xml",
      "Thumbs.db"
    ]
    idField: "file_path"
    recursive: true
    throttleDelayMs: 100
    batchSize: 5
  }

  processors: [
    {
      name: "textExtractor"
      type: "TikaTextExtractor"
      textField: "text"
      extractAllMetadata: true
    },
    {
      name: "renameFields"
      type: "RenameFields"
      renames {
        "Content-Type": "content_type"
      }
    },
    {
      name: "filePathField"
      type: "CopyField"
      source: "id"
      dest: "file_path"
    },
    {
      name: "copyForChunking"
      type: "CopyField"
      source: "text"
      dest: "text_to_chunk"
    },
    {
      name: "chunkText"
      type: "ChunkText"
      field: "text_to_chunk"
      outputField: "chunks"
      chunkSize: 1000
      overlapSize: 100
      idField: "file_path"
      includeParent: false
    },
    {
      name: "emitChunks"
      type: "EmitNestedChildren"
      path: "chunks"
      childrenField: "chunks"
      prefix: "chunk_"
      breakpoint: true
    },
    {
      name: "cleanup"
      type: "DropField"
      fields: ["text_to_chunk"]
    },
    {
      name: "geminiEmbed"
      type: "GeminiEmbed"
      field: "chunk_text"
      vectorField: "chunk_vector"
      modelName: "embedding-001"
      apiKey: ${?GEMINI_API_KEY}
      dimension: 768
    }
  ]

  publisher {
    type: "opensearch"
    name: "opensearchPublisher"
    url: ${OPENSEARCH_URL}
    username: "admin"
    password: "StrongPassword123!"
    verifySsl: false
    index: ${OPENSEARCH_INDEX}
    queueCapacity: 100
    batchSize: 10
    batchTimeout: 10000
  }
}

// Worker configuration to optimize rate limiting
worker {
  pipeline: "pipeline1"
  // Reduced threads to respect Gemini API rate limits
  threads: 2
  // Add sleep between documents to control rate
  sleepBetweenDocs: 50
  // Add delay on processor errors
  sleepOnProcessorError: 500
}
